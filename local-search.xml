<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>跳跃表</title>
    <link href="/2024/09/27/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <url>/2024/09/27/%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>跳跃表(skiplist)由大牛 William Pugh 在论文《Skip lists: a probabilistic alternative to balanced trees》中提出，跳跃表以有序的方式在层次化的链表中保存元素，效率和平衡树媲美：查找、删除、添加等操作都可以在对数期望时间下完成。跳跃表体现了“<strong>空间换时间</strong>”的思想，从本质上来说，跳跃表是在单链表的基础上在选取部分结点添加索引，这些索引在逻辑关系上构成了一个新的线性表，并且索引的层数可以叠加，生成二级索引、三级索引、多级索引，以实现对结点的跳跃查找的功能。与二分查找类似，跳跃表能够在 O(㏒n)的时间复杂度之下完成查找，与红黑树等数据结构查找的时间复杂度相同，但是相比之下，跳跃表能够更好的支持并发操作，而且实现这样的结构比红黑树等数据结构要简单、直观许多。</p><h1 id="结构特点"><a href="#结构特点" class="headerlink" title="结构特点"></a>结构特点</h1><p>跳跃表由多个层级的链表组成。最底层是一个普通的有序链表，包含所有的元素。每个上层链表是通过对下层链表的元素进行一定规则的间隔选取而形成的。例如，每隔一个元素选取一个进入上一层链表，上层链表的元素数量相对下层更少，但依然保持着有序性。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li><p><strong>搜索（Search）</strong>：跳跃表的搜索操作平均时间复杂度为O(㏒n) ，这是因为在每一层，搜索操作都可能跳过多个元素，具体跳过的元素数量取决于随机化过程。</p><p>1）从上到下与索引结点进行比较，逐步缩小需要查询的结点所在的范围（因为跳跃表是有序的数据结构，类似于二分的思想）【平均：O（log N),最坏为O(N)】</p><p><strong>总体来说，跳跃表的查询操作的时间复杂度为O(log N)</strong></p></li><li><p><strong>插入（Insertion）</strong>：插入操作同样具有O(㏒n)的平均时间复杂度。插入时，需要找到插入点，并且可能需要更新多个层的链表。</p><p>1）新结点从上到下与各层索引结点逐一比较，确定在原链表的插入位置：【O(log N）】</p><p>2）确定在原链表的插入位置后直接插入:【O(1)】</p><p>3）利用随机的方式决定新结点上升为几层索引结点：【O(log N)】</p><p>总体来说，<strong>跳跃表的插入操作的时间复杂度是O(log N)</strong></p></li><li><p><strong>删除（Deletion）</strong>：删除操作的时间复杂度也是O(㏒n)，需要找到要删除的元素，并在所有包含该元素的层上进行删除。</p><p>1）自上而下，查找第一次出现结点的索引，并逐层找到每一层对应的结点:【O(log N)】</p><p>2）删除每一层查到的结点，如果该层只剩一个结点，删除整个一层（原链表除外）【O(log N)】</p><p><strong>总的来说，跳跃表的删除操作的时间复杂度是O(log N)</strong></p></li></ul><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>期望空间复杂度 O(n)，最差空间复杂度O(n㏒n)</p><p>对于每层的期待：第一层n，第二层n&#x2F;2，第三层n&#x2F;2^2^，…，直到 n&#x2F;2^log n^&#x3D;1。</p><p>所以，总空间需求：S &#x3D; n + n&#x2F;2 + n&#x2F;2^2^ + … + n&#x2F;2^log n^ &lt; n(1 + 1&#x2F;2 + 1&#x2F;2^2^ + … + 1&#x2F;2^∞^) &#x3D;2n</p><p>因此他的空间复杂度为 2n &#x3D; O(n)</p><p><strong>总的来说，跳跃表的空间复杂度为O(N)</strong></p><h2 id="跳跃表的高度"><a href="#跳跃表的高度" class="headerlink" title="跳跃表的高度"></a>跳跃表的高度</h2><p>对每层来说，它会向上增长的概率为1&#x2F;2，则第m层向上增长的概率为1&#x2F;2^m^；</p><p>n个元素，则在m层元素数目的期待为E<del>m</del> &#x3D; n&#x2F;2^m^；</p><p>当E<del>m</del> &#x3D; 1，m &#x3D; log<del>2</del>n即为层数的期待。</p><p><strong>故其高度期待为 E<del>h</del> &#x3D; O(log n)。</strong></p><h1 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入一个新元素时，首先在最底层链表中进行常规的插入操作，确保链表的有序性。然后，通过随机的方式决定新元素是否要提升到上层链表中。通常使用一个概率值来控制提升的次数，这样可以保证跳跃表的高度在一定范围内保持平衡。如果新元素被提升到上层链表，就继续按照同样的方式决定是否进一步提升到更高层链表，直到不再满足提升条件为止。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除一个元素时，先在跳跃表中找到该元素。然后从最上层链表开始，依次在每个包含该元素的链表中删除它。删除操作不会影响跳跃表的整体结构特性，只是减少了链表中的元素数量。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>当在跳跃表中进行查找操作时，从最上层链表的左端开始。由于上层链表的元素间隔较大，所以可以快速跳过一些不可能包含目标元素的区间。如果当前节点的值小于目标值，就向右移动到下一个节点；如果当前节点的值大于目标值，就下降到下一层链表继续查找。重复这个过程，直到找到目标元素或者到达最底层链表的末尾。这个查找过程类似于在楼梯上跳跃着前进，从而大大提高了查找效率。</p><p>总之，跳跃表通过建立多层级的链表结构，在查找、插入和删除操作上实现了较高的效率，同时具有相对简单的实现方式和良好的性能表现。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
